---
title: 'Influence of inflammation on symptom heterogeneity in PTSD: Moderator Model'
output:
  html_document:
    df_print: paged
  pdf_document: default
  word_document: default
editor_options:
  markdown:
    wrap: 72
---

## Introduction

The aim of the simulation is to calculate and compare the probability
distributions of symptom combinations between individuals with and
without inflammation in a fictitious mental disorder. The disorder is
defined by 5 symptom criteria of which at least 2 must be present to
fulfill diagnostic criteria. The disorder is simulated with a binary
latent variable L, which is present in 80% of the simulated individuals.

Five symptom indicators are simulated: S1, S2, M, W1, and W2, where S
stands for strong indicators, W for weak indicators, and M for a
medium-strength indicator. Each symptom is influenced by the disorder L,
while a second binary latent variable I, representing inflammation,
moderates the strength of L's effect on symptoms. Inflammation is
present in 50% of individuals. The correlation between L and I is 0.6.

Symptoms are measured on a scale from 0 to 4, with values of 2 or higher
indicating symptom presence. Symptom ratings are normally distributed
around a mean of 2, with different standard deviations depending on
indicator strength. The disorder is considered present if at least 2 of
the 5 symptoms are present. Notably, in this moderator model,
inflammation has no effect on symptoms when the disorder is absent
(L=0); inflammation only influences symptom expression through its
moderation of the disorder's effect. The simulation calculates the
probability of each symptom combination separately for individuals with
and without inflammation.

To ensure fair comparison between inflammation groups, we simulate a large population and then select individuals from the non-inflammation group whose symptom severity matches the inflammation group. Specifically, we select non-inflammation individuals whose total symptom severity falls within ±0.5 SD of the inflammation group's mean severity, then randomly sample to achieve equal group sizes.

### Formal Model Specification

For each symptom i âˆˆ {S1, S2, M, W1, W2}:

$$\text{Symptom}_i = (\lambda_{0,i} + \gamma_i \times I) \times L + \varepsilon_i$$

Where:

-   $\lambda_{0,i}$ = baseline effect of L on symptom i (when I = 0)
-   $\gamma_i$ = moderation effect (change in L's effect when I = 1)
-   $\varepsilon_i \sim N(\mu, \sigma^2_i)$ = residual error with mean Î¼
    = 2

### Parameter Values

Effect sizes are based on Cohen's d values, converted to raw units:

| Symptom | Type   | SD  | Cohen's d | Î»â‚€ (d Ã— SD) | Amplification | Î³ (Î»â‚€ Ã— (amp-1)) |
|---------|--------|-----|-----------|-------------|---------------|------------------|
| S1      | Strong | 0.7 | 1.3       | 0.91        | 1.25          | 0.2275           |
| S2      | Strong | 0.7 | 1.3       | 0.91        | 1.25          | 0.2275           |
| M       | Medium | 1.0 | 0.9       | 0.90        | 1.20          | 0.1800           |
| W1      | Weak   | 1.2 | 0.5       | 0.60        | 1.15          | 0.0900           |
| W2      | Weak   | 1.2 | 0.5       | 0.60        | 1.15          | 0.0900           |

```{r setup, include=FALSE}
```

## Set-up

First, the necessary packages are loaded.

```{r library, echo=TRUE, message=FALSE, warning=FALSE}
# Load required packages
library(tidyverse)
library(mvtnorm)
library(MASS)
library(flextable)
library(officer)
```

Second, a seed is set and the general set up is defined.

```{r general_setup, echo=TRUE}
# Setting seed for reproducibility
set.seed(123)

# Combinations of binary criteria
combinations <- expand.grid(c(0,1), c(0,1), c(0,1), c(0,1), c(0,1))
```

Third, a helper function is created to assure that simulated values fall
between 0 and 4 (otherwise they are resampled).

```{r helper_function_rescale, echo=TRUE}
# Function to ensure the values fall between 0 and 4
rescale <- function(x) {
  min_val <- min(x)
  max_val <- max(x)
  return((x - min_val) / (max_val - min_val) * 4)
}
```

Fourth, a function is created to generate correlated binary variables.

```{r helper_function_binary, echo=TRUE}
generate_correlated_binary <- function(n, p1, p2, cor) {
  means <- c(0, 0)
  sigma <- matrix(c(1, cor, cor, 1), 2, 2)
  bvn <- mvrnorm(n, mu = means, Sigma = sigma)
  
  threshold_L <- qnorm(1 - p1)
  threshold_I <- qnorm(1 - p2)
  
  L <- ifelse(bvn[,1] > threshold_L, 1, 0)
  I <- ifelse(bvn[,2] > threshold_I, 1, 0)
  
  return(data.frame(L = L, I = I))
}
```

Fifth, a function is created to calculate the Shannon index. The Shannon
index quantifies heterogeneity by measuring uncertainty in a
distribution, with higher values indicating greater heterogeneity.

```{r shannon_function, echo=TRUE}
# Function to calculate Shannon index
# Input: vector of probabilities
# Output: Shannon index (using natural logarithm)
calculate_shannon <- function(probabilities) {
  # Only use probabilities > 0 (since log(0) is undefined)
  p <- probabilities[probabilities > 0]
  # Normalize to ensure probabilities sum to 1
  p <- p / sum(p)
  # Calculate Shannon index: H = -sum(p * ln(p))
  H <- -sum(p * log(p))
  return(H)
}
```

Sixth, a function is created to calculate Hill numbers. Hill numbers
quantify heterogeneity by measuring the effective number of categories
in a distribution. The parameter q controls sensitivity to rare
categories: q=0 counts all categories equally (richness), q=1 weights
by frequency (exponential of Shannon), and q=2 emphasizes common
categories (inverse Simpson).

```{r hill_function, echo=TRUE}
# Function to calculate Hill numbers
# Input: vector of probabilities, q parameter (order of diversity)
# Output: Hill number (effective number of categories)
calculate_hill <- function(probabilities, q) {
  # Only use probabilities > 0 (since log(0) is undefined for q=1)
  p <- probabilities[probabilities > 0]
  # Normalize to ensure probabilities sum to 1
  p <- p / sum(p)
  
  if (q == 1) {
    # Limit case: exponential of Shannon entropy
    return(exp(-sum(p * log(p))))
  } else {
    # General formula: Hill = (sum(p^q))^(1/(1-q))
    return(sum(p^q)^(1/(1-q)))
  }
}
```

Seventh, the set up of the simulation is defined.

```{r simulation_setup, echo=TRUE}
# Number of individuals and simulations
n <- 10000
n_sims <- 100

# Matrices to accumulate the results of each simulation
results_WITH_inflammation <- matrix(0, ncol = 2^5, nrow = n_sims)
results_WITHOUT_inflammation <- matrix(0, ncol = 2^5, nrow = n_sims)

# Vectors to track sample sizes
n_WITH_inflammation <- numeric(n_sims)
n_WITHOUT_inflammation <- numeric(n_sims)

# Vectors to track symptom severity means
severity_WITH_inflammation <- numeric(n_sims)
severity_WITHOUT_inflammation <- numeric(n_sims)

# Vectors to track Shannon indices for heterogeneity analysis
shannon_WITH_inflammation <- numeric(n_sims)
shannon_WITHOUT_inflammation <- numeric(n_sims)

# Vectors to track Hill numbers for heterogeneity analysis
# q=0: richness, q=1: exp(Shannon), q=2: inverse Simpson
hill_q0_WITH_inflammation <- numeric(n_sims)
hill_q0_WITHOUT_inflammation <- numeric(n_sims)
hill_q1_WITH_inflammation <- numeric(n_sims)
hill_q1_WITHOUT_inflammation <- numeric(n_sims)
hill_q2_WITH_inflammation <- numeric(n_sims)
hill_q2_WITHOUT_inflammation <- numeric(n_sims)
```

## Running Simulations

First, the presence of the mental disorder and inflammation status is
simulated. Each individual has an 80% probability of having the disorder
and a 50% probability of having inflammation, with a correlation of 0.6
between the two. Next, individual symptom ratings are generated for
every simulated individual using the moderator model. In this model,
inflammation (I) does not have a direct effect on symptoms, but instead
moderates (amplifies) the effect of the disorder (L) on symptoms. When
L=0, inflammation has no effect on symptoms. After obtaining the symptom
ratings, new variables are introduced that indicate whether a symptom is
"present" or "absent". A symptom is deemed "present" if its rating is 2
or higher. The presence of the disorder is then evaluated based on the
number of "present" symptoms. If at least 2 out of the 5 symptoms are
deemed present, the disorder is considered to be "present" in that
individual. The diagnosed individuals are then split into two groups:
those with inflammation (I=1) and those without inflammation (I=0).
Finally, the probability of each symptom combination is calculated
separately for each inflammation group across 100 simulations.

```{r simulations, echo=TRUE}
for(sim in 1:n_sims) {
  # Generate correlated binary latent variables L (PTSD) and I (Inflammation)
  latent_vars <- generate_correlated_binary(n, p1 = 0.8, p2 = 0.5, cor = 0.6)
  L <- latent_vars$L
  I <- latent_vars$I
  
  # Define model parameters
  # Baseline effects (Î»â‚€): effect of L when I = 0
  lambda_S1 <- 0.91  # Strong indicator
  lambda_S2 <- 0.91  # Strong indicator
  lambda_M  <- 0.90  # Medium indicator
  lambda_W1 <- 0.60  # Weak indicator
  lambda_W2 <- 0.60  # Weak indicator
  
  # Moderation effects (Î³): additional effect when I = 1
  gamma_S1 <- 0.2275  # 25% amplification
  gamma_S2 <- 0.2275  # 25% amplification
  gamma_M  <- 0.1800  # 20% amplification
  gamma_W1 <- 0.0900  # 15% amplification
  gamma_W2 <- 0.0900  # 15% amplification
  
  # Standard deviations
  sd_strong <- 0.7
  sd_medium <- 1.0
  sd_weak   <- 1.2
  
  # MODERATOR MODEL: Symptom_i = (Î»â‚€ + Î³ Ã— I) Ã— L + Îµ
  # Inflammation only affects symptoms through moderation of L's effect
  # When L = 0, inflammation has NO effect on symptoms
  
  # Strong indicators
  S1 <- rescale((lambda_S1 + gamma_S1 * I) * L + rnorm(n, mean = 2, sd = sd_strong))
  S2 <- rescale((lambda_S2 + gamma_S2 * I) * L + rnorm(n, mean = 2, sd = sd_strong))
  
  # Medium indicator
  M  <- rescale((lambda_M + gamma_M * I) * L + rnorm(n, mean = 2, sd = sd_medium))
  
  # Weak indicators
  W1 <- rescale((lambda_W1 + gamma_W1 * I) * L + rnorm(n, mean = 2, sd = sd_weak))
  W2 <- rescale((lambda_W2 + gamma_W2 * I) * L + rnorm(n, mean = 2, sd = sd_weak))
  
  # Combine into a data frame
  data <- data.frame(L, I, S1, S2, W1, W2, M)
  
  # Creating binary variables for all indicators
  data <- data %>%
    mutate(
      S1_positive = S1 >= 2,
      S2_positive = S2 >= 2,
      W1_positive = W1 >= 2,
      W2_positive = W2 >= 2,
      M_positive = M >= 2
    )
  
  # Calculate a new column that counts how many criteria are met for each individual
  data <- data %>%
    mutate(criteria_met = S1_positive + S2_positive + 
                          W1_positive + W2_positive + 
                          M_positive)
  
  # Filter the dataset to keep only those individuals that meet at least 2 criteria
  filtered_data <- data %>%
    filter(criteria_met >= 2)
  
# Calculate symptom severity (sum of all 5 symptom ratings)
filtered_data <- filtered_data %>%
  mutate(severity = S1 + S2 + M + W1 + W2)

# Split into inflammation groups
filtered_WITH_I <- filtered_data %>% filter(I == 1)
filtered_WITHOUT_I <- filtered_data %>% filter(I == 0)

# === Severity-based sampling for equal groups ===
# Calculate mean and SD of severity in inflammation group
mean_severity_WITH <- mean(filtered_WITH_I$severity)
sd_severity_WITH <- sd(filtered_WITH_I$severity)

# Define selection range: mean Â± 0.5 SD
lower_bound <- mean_severity_WITH - 0.5 * sd_severity_WITH
upper_bound <- mean_severity_WITH + 0.5 * sd_severity_WITH

# Select non-inflammation individuals within this severity range
filtered_WITHOUT_I_eligible <- filtered_WITHOUT_I %>%
  filter(severity >= lower_bound & severity <= upper_bound)

# Determine sample size (minimum of both groups)
n_sample <- min(nrow(filtered_WITH_I), nrow(filtered_WITHOUT_I_eligible))

# Random sample from both groups to get equal sizes
if(n_sample > 5) {
  filtered_WITH_I <- filtered_WITH_I %>% sample_n(n_sample)
  filtered_WITHOUT_I <- filtered_WITHOUT_I_eligible %>% sample_n(n_sample)
}

# Track sample sizes
n_WITH_inflammation[sim] <- nrow(filtered_WITH_I)
n_WITHOUT_inflammation[sim] <- nrow(filtered_WITHOUT_I)

# Track severity means (to verify matching worked)
severity_WITH_inflammation[sim] <- mean(filtered_WITH_I$severity)
severity_WITHOUT_inflammation[sim] <- mean(filtered_WITHOUT_I$severity)
  
  # === Calculate for WITH inflammation group ===
  if(nrow(filtered_WITH_I) > 5) {  # Need sufficient data for covariance
    cov_matrix_WITH <- cov(filtered_WITH_I[, c("S1", "S2", "W1", "W2", "M")])
    means_WITH <- colMeans(filtered_WITH_I[, c("S1", "S2", "W1", "W2", "M")])
    
    for(i in 1:nrow(combinations)){
      lower <- as.numeric(ifelse(combinations[i,] == 1, 2, -Inf))
      upper <- as.numeric(ifelse(combinations[i,] == 1, Inf, 2))
      results_WITH_inflammation[sim, i] <- pmvnorm(lower = lower, 
                                                   upper = upper, 
                                                   mean = means_WITH, 
                                                   sigma = cov_matrix_WITH)
    }
  }
  
  # === Calculate for WITHOUT inflammation group ===
  if(nrow(filtered_WITHOUT_I) > 5) {  # Need sufficient data for covariance
    cov_matrix_WITHOUT <- cov(filtered_WITHOUT_I[, c("S1", "S2", "W1", "W2", "M")])
    means_WITHOUT <- colMeans(filtered_WITHOUT_I[, c("S1", "S2", "W1", "W2", "M")])
    
    for(i in 1:nrow(combinations)){
      lower <- as.numeric(ifelse(combinations[i,] == 1, 2, -Inf))
      upper <- as.numeric(ifelse(combinations[i,] == 1, Inf, 2))
      results_WITHOUT_inflammation[sim, i] <- pmvnorm(lower = lower, 
                                                      upper = upper, 
                                                      mean = means_WITHOUT, 
                                                      sigma = cov_matrix_WITHOUT)
    }
  }

  # === Calculate Shannon indices based on observed counts ===
  # Create combination strings for each individual
  filtered_WITH_I <- filtered_WITH_I %>%
    mutate(combination = paste0(as.integer(S1_positive), 
                                as.integer(S2_positive), 
                                as.integer(W1_positive), 
                                as.integer(W2_positive), 
                                as.integer(M_positive)))

  filtered_WITHOUT_I <- filtered_WITHOUT_I %>%
    mutate(combination = paste0(as.integer(S1_positive), 
                                as.integer(S2_positive), 
                                as.integer(W1_positive), 
                                as.integer(W2_positive), 
                                as.integer(M_positive)))

  # Count combinations and calculate proportions for WITH inflammation group
  counts_WITH <- filtered_WITH_I %>%
    count(combination) %>%
    mutate(proportion = n / sum(n))

  # Count combinations and calculate proportions for WITHOUT inflammation group
  counts_WITHOUT <- filtered_WITHOUT_I %>%
    count(combination) %>%
    mutate(proportion = n / sum(n))

  # Calculate Shannon index for WITH inflammation group
  if(nrow(counts_WITH) > 0) {
    shannon_WITH_inflammation[sim] <- calculate_shannon(counts_WITH$proportion)
  }

  # Calculate Shannon index for WITHOUT inflammation group
  if(nrow(counts_WITHOUT) > 0) {
    shannon_WITHOUT_inflammation[sim] <- calculate_shannon(counts_WITHOUT$proportion)
  }
  # Calculate Hill numbers for WITH inflammation group
  if(nrow(counts_WITH) > 0) {
    hill_q0_WITH_inflammation[sim] <- calculate_hill(counts_WITH$proportion, q = 0)
    hill_q1_WITH_inflammation[sim] <- calculate_hill(counts_WITH$proportion, q = 1)
    hill_q2_WITH_inflammation[sim] <- calculate_hill(counts_WITH$proportion, q = 2)
  }

  # Calculate Hill numbers for WITHOUT inflammation group
  if(nrow(counts_WITHOUT) > 0) {
    hill_q0_WITHOUT_inflammation[sim] <- calculate_hill(counts_WITHOUT$proportion, q = 0)
    hill_q1_WITHOUT_inflammation[sim] <- calculate_hill(counts_WITHOUT$proportion, q = 1)
    hill_q2_WITHOUT_inflammation[sim] <- calculate_hill(counts_WITHOUT$proportion, q = 2)
  }
}
```

The simulation results are processed separately for each inflammation
group. For both the "with inflammation" and "without inflammation"
groups, the mean probability and standard deviation of each symptom
combination across the 100 simulations are calculated. The two groups
are then combined into a single dataset for comparison. Only symptom
combinations that meet diagnostic criteria (â‰¥2 symptoms present) are
retained for analysis. Combinations are ranked by their average
probability across both groups to facilitate visual comparison. Finally,
the average sample sizes for each inflammation group across all
simulations are reported.

```{r calculations, echo=TRUE}
# === Process results for WITH inflammation group ===
derived_probs_WITH <- data.frame(
  Combination = paste(combinations[,1], 
                      combinations[,2], 
                      combinations[,3], 
                      combinations[,4], 
                      combinations[,5], sep=""),
  Mean_Probability = apply(results_WITH_inflammation, 2, mean),
  SD_Probability = apply(results_WITH_inflammation, 2, sd),
  Group = "With Inflammation")

# === Process results for WITHOUT inflammation group ===
derived_probs_WITHOUT <- data.frame(
  Combination = paste(combinations[,1], 
                      combinations[,2], 
                      combinations[,3], 
                      combinations[,4], 
                      combinations[,5], sep=""),
  Mean_Probability = apply(results_WITHOUT_inflammation, 2, mean),
  SD_Probability = apply(results_WITHOUT_inflammation, 2, sd),
  Group = "Without Inflammation")

# Combine both groups
derived_probs_combined <- rbind(derived_probs_WITH, derived_probs_WITHOUT)

# Determine which combinations meet 2 out of 5 criteria
derived_probs_combined$MeetsCriteria <- ifelse(rowSums(combinations) >= 2, TRUE, FALSE)

# Filter to only include combinations that meet the criteria
filtered_probs_combined <- derived_probs_combined %>% 
  filter(MeetsCriteria) %>%
  arrange(Group, desc(Mean_Probability))

# Add abbreviations for x-axis
# We'll rank combinations by their average probability across both groups
avg_probs <- derived_probs_combined %>%
  filter(MeetsCriteria) %>%
  group_by(Combination) %>%
  summarise(Avg = mean(Mean_Probability)) %>%
  arrange(desc(Avg))

filtered_probs_combined$Rank <- match(filtered_probs_combined$Combination, avg_probs$Combination)

# Report average sample sizes
cat("Average sample sizes across simulations:\n")
cat("With Inflammation:", round(mean(n_WITH_inflammation), 1), "\n")
cat("Without Inflammation:", round(mean(n_WITHOUT_inflammation), 1), "\n")

# Report average symptom severity (to verify groups are matched)
cat("\nAverage symptom severity across simulations:\n")
cat("With Inflammation:", round(mean(severity_WITH_inflammation), 2), "\n")
cat("Without Inflammation:", round(mean(severity_WITHOUT_inflammation), 2), "\n")

# === Report Shannon Index Results ===
cat("\n=== HETEROGENEITY ANALYSIS (Shannon Index) ===\n")
cat("Shannon Index (With Inflammation):    ", 
    round(mean(shannon_WITH_inflammation), 3), " ± ", 
    round(sd(shannon_WITH_inflammation), 3), "\n", sep="")
cat("Shannon Index (Without Inflammation): ", 
    round(mean(shannon_WITHOUT_inflammation), 3), " ± ", 
    round(sd(shannon_WITHOUT_inflammation), 3), "\n", sep="")
cat("\nDifference (With - Without): ", 
    round(mean(shannon_WITH_inflammation) - mean(shannon_WITHOUT_inflammation), 3), "\n", sep="")
cat("95% CI of difference: [", 
    round(mean(shannon_WITH_inflammation - shannon_WITHOUT_inflammation) - 
          1.96 * sd(shannon_WITH_inflammation - shannon_WITHOUT_inflammation) / sqrt(n_sims), 3), 
    ", ", 
    round(mean(shannon_WITH_inflammation - shannon_WITHOUT_inflammation) + 
          1.96 * sd(shannon_WITH_inflammation - shannon_WITHOUT_inflammation) / sqrt(n_sims), 3), 
    "]\n", sep="")

# === Report Hill Numbers Results ===
cat("\n=== HETEROGENEITY ANALYSIS (Hill Numbers) ===\n")

# Calculate differences for each simulation
diff_q0 <- hill_q0_WITH_inflammation - hill_q0_WITHOUT_inflammation
diff_q1 <- hill_q1_WITH_inflammation - hill_q1_WITHOUT_inflammation
diff_q2 <- hill_q2_WITH_inflammation - hill_q2_WITHOUT_inflammation

# Create summary data frame
hill_summary <- data.frame(
  Measure = c("Hill q=0 (Richness)", 
              "Hill q=1 (exp Shannon)", 
              "Hill q=2 (inv Simpson)"),
  With_Inflammation_Mean = c(mean(hill_q0_WITH_inflammation),
                              mean(hill_q1_WITH_inflammation),
                              mean(hill_q2_WITH_inflammation)),
  With_Inflammation_SD = c(sd(hill_q0_WITH_inflammation),
                            sd(hill_q1_WITH_inflammation),
                            sd(hill_q2_WITH_inflammation)),
  Without_Inflammation_Mean = c(mean(hill_q0_WITHOUT_inflammation),
                                 mean(hill_q1_WITHOUT_inflammation),
                                 mean(hill_q2_WITHOUT_inflammation)),
  Without_Inflammation_SD = c(sd(hill_q0_WITHOUT_inflammation),
                               sd(hill_q1_WITHOUT_inflammation),
                               sd(hill_q2_WITHOUT_inflammation)),
  Difference = c(mean(diff_q0),
                 mean(diff_q1),
                 mean(diff_q2)),
  CI_95_Lower = c(mean(diff_q0) - 1.96 * sd(diff_q0) / sqrt(n_sims),
                  mean(diff_q1) - 1.96 * sd(diff_q1) / sqrt(n_sims),
                  mean(diff_q2) - 1.96 * sd(diff_q2) / sqrt(n_sims)),
  CI_95_Upper = c(mean(diff_q0) + 1.96 * sd(diff_q0) / sqrt(n_sims),
                  mean(diff_q1) + 1.96 * sd(diff_q1) / sqrt(n_sims),
                  mean(diff_q2) + 1.96 * sd(diff_q2) / sqrt(n_sims))
)

# Round all numeric columns
hill_summary[, 2:8] <- round(hill_summary[, 2:8], 3)

# Print summary table
print(hill_summary)
```

## Results

The tables below showcase the mean probabilities and standard deviations
for all symptom combinations that meet diagnostic criteria, displayed
separately for individuals with and without inflammation. Combinations
are sorted by probability within each group, from most to least common.

```{r show_table, echo=TRUE}
# Add MeetsCriteria column to individual dataframes
derived_probs_WITH$MeetsCriteria <- ifelse(rowSums(combinations) >= 2, TRUE, FALSE)
derived_probs_WITHOUT$MeetsCriteria <- ifelse(rowSums(combinations) >= 2, TRUE, FALSE)

# Show ALL results for WITH inflammation
cat("\n=== WITH INFLAMMATION (all combinations meeting criteria) ===\n")
print(derived_probs_WITH %>% 
        filter(MeetsCriteria) %>% 
        arrange(desc(Mean_Probability)))

# Show ALL results for WITHOUT inflammation
cat("\n=== WITHOUT INFLAMMATION (all combinations meeting criteria) ===\n")
print(derived_probs_WITHOUT %>% 
        filter(MeetsCriteria) %>% 
        arrange(desc(Mean_Probability)))
```

## Visualization

The probabilities of symptom combinations are plotted for both
inflammation groups. Each bar represents a symptom combination that
meets diagnostic criteria (â‰¥2 symptoms present). Orange bars represent
individuals with inflammation, while blue bars represent individuals
without inflammation. Combinations are ordered by their average
probability across both groups. Error bars indicate the standard
deviation across the 100 simulations.

```{r plot, echo=TRUE, message=FALSE, warning=FALSE}
# Define the theme for the figure
Theme_Figure_1a <- 
  theme(
    plot.title = element_text(size=12),
    axis.title.y = element_text(size=9, 
                                margin = margin(t = 0, r = 0, b = 0, l = 0)),
    axis.text.x = element_text(size = 7, angle = 90, hjust = 1, vjust = 0.5),
    axis.text.y = element_text(size=9, 
                               color = "black", 
                               margin = margin(t = 0, r = 0, b = 0, l = 5)),
    axis.ticks = element_blank(),
    panel.grid.major.x = element_blank(), 
    panel.grid.major.y = element_line(size=.2, 
                                      color="black"), 
    panel.grid.minor.y = element_blank(), 
    panel.border = element_rect(colour = "black", 
                                fill=NA, 
                                size=1),
    panel.background = element_rect(fill = "white"),
    legend.position = "bottom")

# Plot with two colors
ggplot(filtered_probs_combined, aes(x = reorder(Combination, -Mean_Probability), 
                                     y = Mean_Probability,
                                     fill = Group)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  geom_errorbar(aes(ymin = Mean_Probability - SD_Probability, 
                    ymax = Mean_Probability + SD_Probability), 
                position = position_dodge(width = 0.9),
                width = 0.25) +
  scale_fill_manual(values = c("With Inflammation" = "#F97134", 
                                "Without Inflammation" = "#3498db")) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.05))) +
  labs(title = "Symptom Combination Probabilities by Inflammation Status (Moderator Model)", 
       x = "Symptom Combinations (S1, S2, W1, W2, M)", 
       y = "Probability",
       fill = "") + 
  Theme_Figure_1a
```
